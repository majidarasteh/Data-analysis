# **1. Reshaping, Transposing, Views vs Copies (NumPy)**

NumPy provides flexible tools for **reshaping arrays**, **transposing matrices**, and understanding **views vs copies**, which are essential for memory-efficient array manipulations.

## **1.1 Reshaping Arrays**

Reshaping changes the **shape of an array** without altering its data. The **total number of elements must remain the same**.

```python
import numpy as np

# 1-D array
arr1D = np.array([1, 2, 3, 4, 5, 6])
print("Original 1-D array:", arr1D)

# Reshape to 2x3
arr2D = arr1D.reshape(2, 3)
print("\nReshaped to 2x3:\n", arr2D)

# Reshape to 3x2
arr3x2 = arr1D.reshape(3, 2)
print("\nReshaped to 3x2:\n", arr3x2)
```

**Output:**

```
Original 1-D array: [1 2 3 4 5 6]

Reshaped to 2x3:
[[1 2 3]
 [4 5 6]]

Reshaped to 3x2:
[[1 2]
 [3 4]
 [5 6]]
```

**2-D Arrays Example**

```python
mat = np.array([[1, 2, 3],
                [4, 5, 6]])
print("\nOriginal 2-D array:\n", mat)

# Reshape 2-D 2x3 to 3x2
reshaped_mat = mat.reshape(3, 2)
print("\nReshaped 2x3 to 3x2:\n", reshaped_mat)
```

**Output:**

```
Original 2-D array:
[[1 2 3]
 [4 5 6]]

Reshaped 2x3 to 3x2:
[[1 2]
 [3 4]
 [5 6]]
```

### **Flattening Arrays Using `.reshape(-1)`**

```python
# Flatten 2-D to 1-D
flat = mat.reshape(-1)
print("\nFlattened to 1-D:", flat)
```

**Output**

```
Flattened to 1-D: [1 2 3 4 5 6]
```

## **1.2 Transposing Arrays**

Transposing swaps **rows and columns**. For 1-D arrays, transpose has no effect.

```python
# 1-D
arr1D = np.array([1,2,3])
print("1-D array transpose (no effect):", arr1D.T)

# 2-D
mat2D = np.array([[1,2,3],
                  [4,5,6]])
print("\nOriginal 2-D matrix:\n", mat2D)

transposed = mat2D.T
print("\nTransposed 2-D matrix:\n", transposed)
```

**Output:**

```
1-D array transpose (no effect): [1 2 3]

Original 2-D matrix:
[[1 2 3]
 [4 5 6]]

Transposed 2-D matrix:
[[1 4]
 [2 5]
 [3 6]]
```

## **1.3 Flatten vs Ravel**

Flatten creates a **copy**, while ravel returns a **view** when possible. Modifying a view affects the original array.

```python
arr = np.array([[1,2,3],[4,5,6]])

flat_copy = arr.flatten()
flat_view = arr.ravel()

print("Original array:\n", arr)
print("\nFlatten (copy):", flat_copy)
print("Ravel (view):", flat_view)

# Modify view
flat_view[0] = 100
print("\nModified Ravel (view) affects original array:\n", arr)

# Modify copy
flat_copy[1] = 200
print("\nModified Flatten (copy) does NOT affect original:\n", arr)
```

**Output:**

```
Original array:
[[1 2 3]
 [4 5 6]]

Flatten (copy): [1 2 3 4 5 6]
Ravel (view): [1 2 3 4 5 6]

Modified Ravel (view) affects original array:
[[100   2   3]
 [  4   5   6]]

Modified Flatten (copy) does NOT affect original:
[[100   2   3]
 [  4   5   6]]
```

## **1.4 Reshape with -1 (Automatic Dimension)**

The `-1` argument lets NumPy **automatically infer** the size of one dimension.

```python
arr = np.arange(12)
print("Original array:", arr)

# Automatically determine second dimension
reshaped = arr.reshape(3, -1)
print("\nReshaped 3x-1:\n", reshaped)

reshaped2 = arr.reshape(-1, 3)
print("\nReshaped -1x4:\n", reshaped2)
```

**Output:**

```
Original array: [ 0  1  2  3  4  5  6  7  8  9 10 11]

Reshaped 3x-1:
 [[ 0  1  2  3]
 [ 4  5  6  7]
 [ 8  9 10 11]]

Reshaped -1x4:
 [[ 0  1  2]
 [ 3  4  5]
 [ 6  7  8]
 [ 9 10 11]]
```

## **1.5 Views (`view()`) vs Copies (`.copy()`)**

Understanding **memory behavior** is essential for efficiency:

* **View:** Shares the same data, modifying it affects the original.
* **Copy:** Independent data, modifying it does not affect the original.

```python
arr = np.array([1,2,3,4,5])

# View
view_arr = arr.view()
view_arr[0] = 100
print("Original after modifying view:", arr)

# Copy
copy_arr = arr.copy()
copy_arr[1] = 200
print("Original after modifying copy:", arr)
```

**Output:**

```
Original after modifying view: [100   2   3   4   5]
Original after modifying copy: [100   2   3   4   5]
```

## **1.6 Transpose and Axes for Higher Dimensions - `.transpose()`**

For 3-D arrays, you can **swap axes** using `transpose`:

```python
arr3D = np.arange(24).reshape(2,3,4)
print("Original 3-D shape:", arr3D.shape)
print(arr3D)

# Swap axes
arr3D_T = arr3D.transpose(1,0,2)
print("Transposed shape (1,0,2):", arr3D_T.shape)
print(arr3D_T)
```

**Output:**

```
Original 3-D shape: (2, 3, 4)
[[[ 0  1  2  3]
  [ 4  5  6  7]
  [ 8  9 10 11]]

 [[12 13 14 15]
  [16 17 18 19]
  [20 21 22 23]]]
Transposed shape (1,0,2): (3, 2, 4)
[[[ 0  1  2  3]
  [12 13 14 15]]

 [[ 4  5  6  7]
  [16 17 18 19]]

 [[ 8  9 10 11]
  [20 21 22 23]]]
```

---

## **1.7 Summary Table â€” Reshaping, Transposing, Views vs Copies**

| **Operation**       | **Function / Method** | **Description**                                          | **Example**                       |
| ------------------- | --------------------- | -------------------------------------------------------- | --------------------------------- |
| Reshape             | `reshape()`           | Change shape without altering data                       | `arr.reshape(2,3)`                |
| Flatten             | `flatten()`           | Return a **copy** as 1-D array                           | `arr.flatten()`                   |
| Ravel               | `ravel()`             | Return a **view** as 1-D array                           | `arr.ravel()`                     |
| Transpose           | `.T`, `transpose()`   | Swap rows and columns (or axes in higher dimensions)     | `mat.T`, `arr3D.transpose(1,0,2)` |
| Automatic Dimension | `-1` in `reshape()`   | NumPy infers dimension automatically                     | `arr.reshape(3,-1)`               |
| View                | `view()`              | New array sharing the same data                          | `arr.view()`                      |
| Copy                | `copy()`              | Independent array, modifying it does not affect original | `arr.copy()`                      |

