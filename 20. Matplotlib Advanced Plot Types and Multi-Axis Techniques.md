# **Advanced Plot Types & Multi-Axis Techniques**

## **1. Stackplot**

A **stackplot** is used to show how different components contribute to a whole over time. It’s like a layered area plot, where each layer sits on top of the previous one.

It is especially helpful for:

* Visualizing **changes in distribution** over time
* Showing **accumulation** of multiple categories
* Displaying **trends** where all categories sum together

### **Example: Stackplot of three categories**

```python
import matplotlib.pyplot as plt
import numpy as np

x = np.arange(1, 11)
A = [4, 3, 2, 4, 3, 4, 4, 5, 3, 3]
B = [1, 3, 4, 2, 3, 1, 4, 4, 3, 4]
C = [6, 4, 4, 5, 4, 4, 5, 6, 4, 3]

plt.figure(figsize=(8, 5))
plt.stackplot(x, A, B, C, labels=['A', 'B', 'C'], alpha=0.8)

plt.title("Stackplot Example")
plt.xlabel("Time")
plt.ylabel("Value")
plt.legend()
plt.show()
```

**Output**

<img width="716" height="480" alt="image" src="https://github.com/user-attachments/assets/630ae4b6-5f69-4a7d-af1d-b799e81b33d5" />

### **What to notice**

* The bottom layer shows category **A**
* Category **B** is stacked on top of A
* Category **C** is stacked above: A+B
* The top boundary shows the *total* of all components

### **Example 2: Stackplot of three categories**

```python
import matplotlib.pyplot as plt
import numpy as np

x = np.arange(1, 11)
A = np.random.randint(2, 6, 10)
B = np.random.randint(1, 5, 10)
C = np.random.randint(3, 7, 10)
D = np.random.randint(1, 7, 10)

plt.figure(figsize=(8, 5))
plt.stackplot(x, A, B, C, D, labels=['Comapny A', 'Comapny B', 'Comapny C', 'Comapny D'], alpha=0.8)

plt.title("Stackplot Example")
plt.xlabel("Time")
plt.ylabel("Value")
plt.legend()
plt.show()
```

**Output**

<img width="728" height="468" alt="image" src="https://github.com/user-attachments/assets/0165832a-0ed2-4fa9-a346-32fb8cdd2544" />

### **What to notice**

* The bottom layer shows category **Company A**
* Category **Company B** is stacked on top of Company A
* Category **Company C** is stacked above: Company A + Company B
* Category **Company D** is stacked above: Company A + Company B + Company C
* The top boundary shows the *total* of all components

---

## **2. Subplots (`plt.subplots`)**

Subplots let you place **multiple charts in one figure**. This is extremely useful when:

* Comparing different variables
* Showing multiple views of your data
* Creating dashboards or summary figures
* `fig, ax = plt.subplots()` → single plot, but more flexible than `plt.plot`
* Custom grids like `plt.subplots(1, 3)` or `plt.subplots(3, 1)`

### 2.1 Basic usage:

```python
import matplotlib.pyplot as plt

fig, axs = plt.subplots(2, 2, figsize=(10, 8))

x = ["A", "B", "C", "D"]
y = [1, 6, 3, 7]
axs[0, 0].plot(x, y)
axs[0, 1].bar(x, y)
axs[1, 0].scatter(x, y)
axs[1, 1].pie(y, labels = x, autopct="%1.2f%%")

plt.tight_layout()
plt.show()
```

**Output**

<img width="1000" height="800" alt="image" src="https://github.com/user-attachments/assets/e643f9ca-eeb7-42e4-90a0-183c00ad5d70" />

### What you gain from `subplots`

* Cleaner, organized multi-plot figures
* Easy access to each subplot through `axs[row][col]`
* Independent titles, axis labels, or scales

### 2.2 Subplots with Titles, Sub-Titles, and Labels:

* `fig.suptitle("Title")`: Adds a big main title to the entire figure.
* `axes[i, j].set_title("Sub-title")`: Adds a subtitle to that specific subplot.
* `axes[i, j].set_xlabel()`  or  `axes[i, j].set_ylabel()`: Adds $X$ and $Y$ labels for each subplot.
* `plt.tight_layout()`: Adjusts spacing to avoid overlap and reserves space for the main title.

```python
import matplotlib.pyplot as plt
import numpy as np

# Sample Data
x = np.linspace(0, 10, 100)

# Create subplot grid
fig, axes = plt.subplots(2, 2, figsize=(10, 8))

# MAIN title for the whole figure
fig.suptitle("Overview of Different Plot Types", fontsize=16, weight="bold")

# ----- Subplot 1 -----
axes[0, 0].plot(x, np.sin(x))
axes[0, 0].set_title("Sine Wave")           # Subtitle
axes[0, 0].set_xlabel("X-axis")             # X label
axes[0, 0].set_ylabel("sin(x)")             # Y label

# ----- Subplot 2 -----
axes[0, 1].plot(x, np.cos(x), color="green")
axes[0, 1].set_title("Cosine Wave")
axes[0, 1].set_xlabel("X-axis")
axes[0, 1].set_ylabel("cos(x)")

# ----- Subplot 3 -----
axes[1, 0].scatter(x, np.tan(x), color="red")
axes[1, 0].set_title("Tangent (Scatter)")
axes[1, 0].set_xlabel("X-axis")
axes[1, 0].set_ylabel("tan(x)")

# ----- Subplot 4 -----
axes[1, 1].hist(np.random.randn(200), bins=20, color="orange")
axes[1, 1].set_title("Random Histogram")
axes[1, 1].set_xlabel("Value")
axes[1, 1].set_ylabel("Frequency")

# Improving spacing so titles and labels don’t overlap
plt.tight_layout()  # leaves space for the main title
plt.show()
```

**Output**

<img width="1000" height="800" alt="image" src="https://github.com/user-attachments/assets/dc3416fe-f900-432c-930d-0c0f0fe7a5e6" />


### **2.3 Shared X-Axis or Y-Axis - `sharex=True` or `sharey=True`**
All subplots share the same `x-axis` or `y-axis`, so zooming/scrolling will affect all.
* `sharex=True` or `sharey=True` → aligns plots for comparison

#### Share X-axis

```python
fig, axes = plt.subplots(3, 1, sharex=True, figsize=(6, 8))

axes[0].plot([1, 2, 3], [1, 4, 2])
axes[1].bar([1, 2, 3], [2, 3, 1])
axes[2].barh([1, 2, 3], [3, 2, 4])

plt.show()
```

**Output**

<img width="600" height="800" alt="image" src="https://github.com/user-attachments/assets/077b8059-7625-4443-8858-201834065175" />

#### Share Y-axis

```python
fig, axes = plt.subplots(3, 1, sharey=True, figsize=(6, 8))

axes[0].plot([1, 2, 3], [1, 4, 2])
axes[1].bar([1, 2, 3], [2, 3, 1])
axes[2].barh([1, 2, 3], [3, 2, 4])

plt.show()
```

**Output**

<img width="1000" height="500" alt="image" src="https://github.com/user-attachments/assets/8133d66a-7e79-4111-8713-37288cbf786d" />


---

## **3. Twin Axes (`twinx`, `twiny`)**

**Twin axes** allow you to plot two datasets that share the **same x-axis** or **same y-axis**, but have **different scales**.

This is perfect for real-world data where two quantities:

* move together over time
* but have different units or magnitudes. e.g.:
  * Temperature (°C) and Humidity (%) over time
  * Sales (units) and Revenue ($)
  * Height (cm) and Weight (kg)

### **3.1 `twinx()` — Adds a Second Y-Axis**

**Two Y-axes** on the left and right with the **same X-axis**.

```python
import matplotlib.pyplot as plt
import numpy as np

x = np.arange(1, 11)
y1 = np.random.randint(10, 40, 10)
y2 = np.random.randint(200, 400, 10)

fig, ax1 = plt.subplots()

ax1.plot(x, y1, label="Temperature", linewidth=2, color='red')
ax1.set_ylabel("Temperature (°C)")

ax2 = ax1.twinx()
ax2.plot(x, y2, '--', label="Humidity", linewidth=2)
ax2.set_ylabel("Humidity (%)")

plt.title("Twin Axes Example")
plt.show()
```

**Output**

<img width="650" height="442" alt="image" src="https://github.com/user-attachments/assets/c5ba87a5-7678-4aa0-a246-1cfe03c94751" />


### **3.2 `twiny()` — Adds a Second X-Axis**

**Two X-axes** on the top and bottom with the **same y-axis**.

```python
import matplotlib.pyplot as plt
import numpy as np

y = np.linspace(0, 10, 100)
x1 = y * 2           # Bottom axis
x2 = y ** 2         # Top axis (different scale)

fig, ax1 = plt.subplots()

ax1.plot(x1, y, color='green')
ax1.set_xlabel("X1 (Scaled ×2)", color='green')
ax1.set_ylabel("Y")

# Create second X-axis on top
ax2 = ax1.twiny()
ax2.plot(x2, y, color='purple')
ax2.set_xlabel("X2 (Scaled ^2)", color='purple')

plt.title("Twin X-Axis Example")
plt.show()
```

**Output**

<img width="591" height="502" alt="image" src="https://github.com/user-attachments/assets/d59b7e9c-a8f9-4d27-9199-2bc7c0b19e9f" />


### Key advantages:

* Compare incompatible units on the same timeline
* Avoid scale distortion caused by normalizing data
* Keep plots visually aligned

---
