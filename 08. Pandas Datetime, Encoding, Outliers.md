# **Datetime, Encoding, Outliers**

# **1 Datetime Handling in Pandas**

Pandas provides powerful tools for converting, extracting, filtering, and performing arithmetic with dates.

## **1.1 `pd.to_datetime()` — Convert column to datetime**

Converts strings or numbers into pandas datetime objects.

### **Example**

```python
import pandas as pd

df = pd.DataFrame({
    "date": ["2024-01-05", "2024-02-10", "2024-03-29"],
    "Price": [10, 20, 15]
})

df["date"] = pd.to_datetime(df["date"])
print(df)
```

### **Output**

```
        date  Price
0 2024-01-05     10
1 2024-02-10     20
2 2024-03-29     15
```

## **1.2 Extracting Date Parts (`dt.year`, `dt.month`, `dt.day`)**

### **Example**

```python
df["year"] = df["date"].dt.year
df["month"] = df["date"].dt.month
df["day"] = df["date"].dt.day

print(df)
```

### **Output**

```
        date  Price  year  month  day
0 2024-01-05     10  2024      1    5
1 2024-02-10     20  2024      2   10
2 2024-03-29     15  2024      3   29
```

## **1.3 Filtering by Date**

### **Example**

```python
filtered = df[df["date"] >= "2024-02-01"]
print(filtered)
```

### **Output**

```
        date  Price  year  month  day
1 2024-02-10     20  2024      2   10
2 2024-03-29     15  2024      3   29
```

## **1.4 Datetime Arithmetic**

### **Example**

```python
df["date_plus_7"] = df["date"] + pd.Timedelta(days=7)
print(df)
```

### **Output**

```
        date  Price  year  month  day date_plus_7
0 2024-01-05     10  2024      1    5  2024-01-12
1 2024-02-10     20  2024      2   10  2024-02-17
2 2024-03-29     15  2024      3   29  2024-04-05
```

---

# **2. Encoding (Handling Categorical Data)**

**Three major encoding methods:**

1. **Label Encoding** (convert text → integer labels)
2. **One-Hot Encoding** (`get_dummies`)
3. **Category dtype** (memory optimization)


## **2.1 Label Encoding**

Convert **categories to integers**. Useful for ordinal categories (Low < Medium < High).

### **Example**

```python
import pandas as pd
from sklearn.preprocessing import LabelEncoder

df = pd.DataFrame({
    "City": ["Paris", "London", "Paris", "Berlin"]
})

encoder = LabelEncoder()
df["City_encoded"] = encoder.fit_transform(df["City"])
print(df)
```

### **Output**

```
     City  City_encoded
0   Paris             2
1  London             1
2   Paris             2
3  Berlin             0
```

## **2.2 One-Hot Encoding (`get_dummies`)**
One-Hot Encoding is a method used in **machine learning** and data preprocessing to **convert categorical (text-based) values into numerical format** so that algorithms can understand and use them. It transforms each category into a separate binary column:

* 1 → the row **belongs to that category**
* 0 → the row does **not belong to that category**

This avoids giving categories a false order (unlike Label Encoding).


### **Example**

```python
df = pd.get_dummies(df, columns=["City"], drop_first=False)
print(df)
```

### **Output**

```
   City_Berlin  City_London  City_Paris
0            0            0           1
1            0            1           0
2            0            0           1
3            1            0           0
```

## **2.3 Convert to Categorical Type**
Convert to Categorical Type means changing a column in a DataFrame to the categorical data type in pandas. Categorical data is useful **when a column has a limited number of repeating values**, such as:
* colors (Red, Blue, Green)
* sizes (Small, Medium, Large)
* gender (Male, Female)
* product categories
* labels
* grades

### Why Convert a Column to Categorical?
1. **Saves Memory**
   Categorical data uses codes instead of full strings. Example: **Instead of storing "Large"** many times, pandas stores an **integer like 2**.
2. **Enables Faster Processing**
   Operations like grouping, sorting, filtering, and comparisons become faster.
3. **Allows Ordered Categories**
   Important for ordinal data such as: `Small < Medium < Large`. You can explicitly set the order.


### **Example**

```python
df = pd.DataFrame({
    "grade": ["A", "B", "A", "C"]
})

df["grade"] = df["grade"].astype("category")
print(df["grade"].dtypes)
```

### **Output**

```
0    A
1    B
2    A
3    C
Name: grade, dtype: category
Categories (3, object): ['A', 'B', 'C']
```

# **3. Outlier Detection & Handling**

**Outliers** are data points that are significantly different from the rest of the dataset. They may be unusually high, unusually low, or simply incorrect values caused by:
* Data entry errors
* Sensor malfunctions
* Extreme real-world behavior
* Wrong measurement units
* Outliers can distort averages, affect model performance, or mislead statistical analysis.

Outliers can distort averages, affect model performance, or mislead statistical analysis. Common methods:

1. **Z-Score Method**
2. **IQR Method**
3. **Capping (Winsorizing)**
4. **Removing Outliers**

## **3.1. Z-Score Method**

Values with `|z| > 3` are usually outliers.

### **Example**

```python
import pandas as pd
import numpy as np

df = pd.DataFrame({
    "value": [10, 12, 11, 13, 12, 500]   # 500 is an outlier
})

df["zscore"] = (df["value"] - df["value"].mean()) / df["value"].std()
print(df)
```

### **Output**

```
   value    zscore
0     10 -0.377926
1     12 -0.353371
2     11 -0.365649
3     13 -0.329094
4     12 -0.353371
5    500  1.779411   <-- outlier
```

## **3.2. IQR Method (Common Methods to Detect Outliers)**

**What Are Q1, Q3, and IQR?**

1. **Q1 (First Quartile)**
   * **Q1** is the **25th** percentile of the data.
   * It means 25% of the values are below Q1.

2. **Q3 (Third Quartile)**
   * **Q3** is the **75th** percentile of the data.
   * It means 75% of the values are below Q3.

3. **IQR (Interquartile Range)**
   * $IQR = Q3 − Q1$
   * It measures the **middle 50%** of the data.
   * It shows how spread out the central values are.

**Example**

```python
Original: [12, 5, 7, 20, 3]
Sorted:   [3, 5, 7, 12, 20]
```
**1. Find Q1**
* **Q1** is the median of the lower half of the data
* Lower half (below the middle): [3, 5]
* Q1 = median of [3, 5] = 4 (or 5 if using pandas percentile)

**2. Find Q3**
* Q3 is the median of the upper half of the data
* Upper half (above the middle): [12, 20]
* Q3 = median of [12, 20] = 16

**3. IQR**
```python
Q1 = df["value"].quantile(0.25)
Q3 = df["value"].quantile(0.75)
IQR = Q3 - Q1
```

Outliers are values outside:

**[Q1 − 1.5×IQR, Q3 + 1.5×IQR]**

Pandas uses percentile formulas, not just half-splitting, so results may vary slightly.
 
### **Example: how Pandas Computes Q1, Q3, and IQR?**

```python
df = pd.DataFrame({
    "value": [-40, 11, 13, 14, 15, 17, 19, 20, 21, 21, 25, 28, 29, 300]   # 500 is an outlier
})

Q1 = df["value"].quantile(0.25)   # 14+(15-14)*0.25
Q3 = df["value"].quantile(0.75)   # 25-(25-21)*0.25

print("Q1 is: ", Q1)
print("Q3 is: ", Q3)

IQR = Q3 - Q1
print("IQR: ", IQR)
```

### **Output**

```
Q1 is:  14.25
Q3 is:  24.0
IQR:  9.75
```

### Example of detection of outliers by Pandas IQR method

```python
df = pd.DataFrame({
    "value": [10, 12, 11, 13, 12, 500]   # 500 is an outlier
})

Q1 = df["value"].quantile(0.25)
Q3 = df["value"].quantile(0.75)
IQR = Q3 - Q1

lower = Q1 - 1.5 * IQR
upper = Q3 + 1.5 * IQR

outliers = df[(df["value"] < lower) | (df["value"] > upper)]
print(outliers)
```

### **Output**

```
   value    zscore
5    500  1.779411
```

## **3.3. Removing Outliers**

```python
clean_df = df[(df["value"] >= lower) & (df["value"] <= upper)]
print(clean_df)
```

### **Output**

```
   value    zscore
0     10 -0.377926
1     12 -0.353371
2     11 -0.365649
3     13 -0.329094
4     12 -0.353371
```

## **3.4. Capping (Winsorizing)**

Replace outliers with nearest acceptable boundary. **Instead of removing or replacing outliers with `NaN`, we**:

* Replace values below a lower threshold with the lower threshold
* Replace values above an upper threshold with the upper threshold

This keeps all rows intact without deleting or losing data.

### **Example**

```python
df = pd.DataFrame({
    "value": [-40, 11, 13, 14, 15, 17, 19, 20, 21, 21, 25, 28, 29, 300]   # 500 is an outlier
})

Q1 = df["value"].quantile(0.25)
Q3 = df["value"].quantile(0.75)

IQR = Q3 - Q1

lower = Q1 - 1.5 * IQR
upper = Q3 + 1.5 * IQR

print("lower: ", lower)
print("upper: ", upper)

df["capped"] = df["value"].clip(lower, upper)
print(df)
```

### **Output**

```
   value    zscore  capped
lower:  -0.375
upper:  38.625
    value  capped   <-- capped
0     -40  -0.375
1      11  11.000
2      13  13.000
3      14  14.000
4      15  15.000
5      17  17.000
6      19  19.000
7      20  20.000
8      21  21.000
9      21  21.000
10     25  25.000
11     28  28.000
12     29  29.000
13    300  38.625    <-- capped
```
